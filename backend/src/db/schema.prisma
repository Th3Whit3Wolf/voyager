generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "darwin", "linux-musl"]
}

generator docs {
  provider = "node node_modules/prisma-docs-generator"
  output   = "../../../docs/db"
}

generator dbml {
  provider            = "prisma-dbml-generator"
  output              = "../../../assets"
  outputName          = "voyager.dbml"
  projectName         = "Voyager"
  projectDatabaseType = "PostgreSQL"
  projectNote         = "Better In/Out-Processing"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UnitKind {
  INSTALLATION
  COMMAND
  DELTA
  SQUADRON
}

model Unit {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  abbrev    String?  @db.VarChar(64)
  kind      UnitKind
  function  String?  @db.Text
  location  String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  /// Define possible relationship with parent Unit
  /// Rename collumn to conform to SQL naming conventions
  parentID Int?  @map("parent_id")
  parent   Unit? @relation("ParentUnit", fields: [parentID], references: [id])

  /// Define possible relationship with grandparent Unit
  /// Rename collumn to conform to SQL naming conventions
  grandParentID Int?  @map("grand_parent_id")
  grandParent   Unit? @relation("GrandParentUnit", fields: [grandParentID], references: [id])

  /// Define possible relationship with installation Unit
  /// Rename collumn to conform to SQL naming conventions
  installationID Int?  @map("installation_id")
  installation   Unit? @relation("InstallationUnit", fields: [installationID], references: [id])

  /// One-to-Many Relationships
  children             Unit[] @relation("ParentUnit")
  grandChildren        Unit[] @relation("GrandParentUnit")
  installationChildren Unit[] @relation("InstallationUnit")
  Role                 Role[] @relation("Admin Of Unit")
  assignedUsers        User[] @relation("Current unit of user")
  gainingUsers         User[] @relation("Gaining unit of user")

  /// Rename table to units to conform to
  /// SQL naming conventions
  @@map("units")
}

enum ProcessingStatus {
  IN_PROCESSING
  IN_TRANSIT
  OUT_PROCESSING
  OUT_PROCESSING_WITH_ORDERS
  STATIONARY
}

enum RoleKind {
  USER
  SITE_ADMIN
  COMMAND_ADMIN
  INSTALLATION_ADMIN
  DELTA_ADMIN
  SQUADRON_ADMIN
}

enum TaskStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}

model Role {
  id        Int      @id @default(autoincrement())
  kind      RoleKind
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  /// Define possible relationship with Unit
  /// Rename collumn to conform to SQL naming conventions
  unitID Int?  @map("unit_id")
  unit   Unit? @relation("Admin Of Unit", fields: [unitID], references: [id])

  /// One-to-Many relationships
  users User[] @relation("Role of user")

  /// Rename table to roles to conform to
  /// SQL naming conventions
  @@map("roles")
}

model User {
  id            Int              @id @default(autoincrement())
  firstName     String           @db.VarChar(64)
  lastName      String           @db.VarChar(64)
  email         String           @unique @db.VarChar(128)
  dsn           String?          @db.VarChar(32)
  auth          String
  officeSymbol  String           @db.VarChar(64)
  status        ProcessingStatus
  sperationDate DateTime         @default(dbgenerated("NOW() + interval '4 year'")) @map("seperation_date")
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @default(now()) @updatedAt

  /// Define possible relationship with Unit
  /// Rename collumn to conform to SQL naming conventions
  assignedUnitID Int  @map("assigned_unit_id")
  assignedUnit   Unit @relation("Current unit of user", fields: [assignedUnitID], references: [id])

  /// Define possible relationship with Unit
  /// Rename collumn to conform to SQL naming conventions
  gainingUnitID Int?  @map("gaining_unit_id")
  gainingUnit   Unit? @relation("Gaining unit of user", fields: [gainingUnitID], references: [id])

  /// Define possible relationship with Role
  /// Rename collumn to conform to SQL naming conventions
  roleID Int?  @map("role_id")
  role   Role? @relation("Role of user", fields: [roleID], references: [id])

  /// Define possible relationship with User
  /// Rename collumn to conform to SQL naming conventions
  supervisorID Int?  @map("supervisor_id")
  supervisor   User? @relation("Supervisor of user", fields: [supervisorID], references: [id])

  /// One-to-Many relationships
  subordinates User[] @relation("Supervisor of user")

  /// Rename table to units to conform to
  /// SQL naming conventions
  @@map("users")
}
